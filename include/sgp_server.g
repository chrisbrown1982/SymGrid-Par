#############################################################################
#
# This is the SCSCP server configuration file.
# The service provider can start the server just by the command 
# $ gap myserver.g
#
# $Id: myserver.g 3120 2009-05-31 20:10:54Z alexk $
#
#############################################################################

#############################################################################
#
# Load necessary packages and read external files. 
# Put here and other commands if needed.
#
#############################################################################

LogTo(); # to close log file if it was opened from .gaprc
LoadPackage("scscp");
LoadPackage("anupq");
LoadPackage("monoid");
Read("sumEuler.g");
Read("karatsuba.g");

SetInfoLevel(InfoSCSCP,4);

#############################################################################
#
# Procedures and functions available for the SCSCP server
# (you can also install procedures contained in other files,
# including standard GAP procedures and functions) by adding
# appropriate calls to InstallSCSCPprocedure below.
#
#############################################################################


#############################################################################
#
# IdGroupByGenerators( <list of permutations> )
# 
# Returns the number of the group, generated by given permutations,
# in the GAP Small Groups Library.
# 
IdGroupByGenerators:=function( permlist )
return IdGroup( Group( permlist ) );
end;


#############################################################################
#
# IdGroup512ByCode( <pcgs code of the group> )
# 
# The function accepts the integer number that is the code for pcgs of 
# a group of order 512 and returns the number of this group in the
# GAP Small Groups library. It is assumed that the client will make sure
# that the code really corresponds to the group of order 512, since this
# can not be checked from the code itself.
#
IdGroup512ByCode:=function( code )
local G, F, H;
G := PcGroupCode( code, 512 );
F := PqStandardPresentation( G );
H := PcGroupFpGroup( F );
return IdStandardPresented512Group( H );
end;


#############################################################################
#
#  QuillenSeriesByIdGroup( [ ord, nr] )
#  
# Let G:=SmallGroup( ord, nr ) be a p-group of order p^n. It was proved in 
# [D.Quillen, The spectrum of an equivariant cohomology ring II, Ann. of 
# Math., (2) 94 (1984), 573-602] that the number of conjugacy classes of 
# maximal elementary abelian subgroups of given rank is determined by the 
# group algebra KG. 
# The function calculates this numbers for each possible rank and returns 
# a list of the length n, where i-th element corresponds to the number of
# conjugacy classes of maximal elementary abelian subgroups of the rank i.
#
QuillenSeriesByIdGroup := function( id )
local G, qs, latt, msl, ccs, ccs_repr, i, x, n;
G := SmallGroup( id );
latt := LatticeSubgroups(G);
msl := MinimalSupergroupsLattice(latt);
ccs := ConjugacyClassesSubgroups(latt);
ccs_repr := List(ccs, Representative);
qs := [];
for i in [ 1 .. LogInt( Size(G), PrimePGroup(G) ) ] do
  qs[i]:=0;
od;
for i in [ 1 .. Length(ccs_repr) ] do 
  if IsElementaryAbelian( ccs_repr[i] ) then
    if ForAll( msl[i], 
               x -> IsElementaryAbelian( ccs[x[1]][x[2]] ) = false ) then
      n := LogInt( Size(ccs_repr[i]), PrimePGroup(G) );
      qs[n] := qs[n] + 1;
    fi;
  fi;
od;
return [ id, qs ];
end;


PointImages:=function( G, n )
local g;
return Set( List( GeneratorsOfGroup(G), g -> n^g ) );
end;

Plus:=function(x,y)
return (x+y);
end;

Fib1:=function(s, x)
#return (((Fibonacci ((x mod 20) + 10)) + x) mod s);
return ((x +1) mod s);
end;

Fib2:=function(s, x)
#return (((Fibonacci ((x mod 10) + 20)) + x) mod s);
return ((x+2) mod s);
end;

Fib3:=function(s, x)
#return (((Fibonacci ((x mod 19) + 10)) + x-1) mod s);
return ((x+3) mod s);
end;

# some services for mathieugroup 24 permutations...
m := MathieuGroup(24);

Mat1:=function(s,x)
Print("\nReceived in Mat1 : ", x);
return (x ^ m.1);
end;

Mat2:=function(s,x)
return (x ^ m.2);
end;

Mat3:=function(s,x)
return (x ^ m.3);
end; 

# some services for manipulation of finite fields
mg := SL(3,3);
gens := GeneratorsOfGroup(mg);

Fin1:=function(s,x)
Print("Arg: ",x);
return (x ^ mg.1);
end;

Fin2:=function(s,x)
return (x ^ mg.2);
end; 

#############################################################################
#
# Installation of procedures to make them available for WS 
# (you can also install procedures contained in other files,
# including standard GAP procedures and functions)
#
#############################################################################

# Test services for Orbit, taken from TFP PAPER, added by CMB 15/07/2010
InstallSCSCPprocedure( "WS_Fib1", Fib1, "Fibonacci modulo 20", 2, 2);
InstallSCSCPprocedure( "WS_Fib2", Fib2, "Fibonacci modulo 10", 2, 2);
InstallSCSCPprocedure( "WS_Fib3", Fib3, "Fibonacci modulo 19", 2, 2);

# Test services for th MathieuGroup 24 permutations  11/08/2010
InstallSCSCPprocedure( "WS_Mat1", Mat1, "MatheiuGroup24 Generator 1", 2, 2);
InstallSCSCPprocedure( "WS_Mat2", Mat2, "MatheiuGroup24 Generator 2", 2, 2);
InstallSCSCPprocedure( "WS_Mat3", Mat3, "MatheiuGroup24 Generator 3", 2, 2);

# Test services for some finite field matrices 12/08/2010
InstallSCSCPprocedure( "WS_Fin1", Fin1, "finiteFIeld 1", 2, 2);
InstallSCSCPprocedure( "WS_Fin2", Fin2, "finiteField 2", 2, 2);

# Simple procedures for tests and demos
InstallSCSCPprocedure( "WS_Factorial", Factorial, "See ?Factorial in GAP", 1, 1 );
InstallSCSCPprocedure( "WS_Fibonacci", Fibonacci, "See ?Fibonacci in GAP", 1, 1 );
InstallSCSCPprocedure( "WS_Phi", Phi, "Euler's totient function, see ?Phi in GAP", 1, 1 );
InstallSCSCPprocedure( "WS_Plus", Plus, "Integer addition", 2, 2 );

InstallSCSCPprocedure( "WS_sumEulerClassic", sumEuler_classic, "see sumEuler.g", 1, 2);
InstallSCSCPprocedure( "WS_SumEulerRange", SumEulerRange, "see sumEuler.g", 1, 2);

# Group identification in the GAP small group library
InstallSCSCPprocedure( "GroupIdentificationService", IdGroupByGenerators, 
	"Accepts a list of permutations and returns IdGroup of the group they generate", 1, infinity );
InstallSCSCPprocedure( "WS_IdGroup", IdGroup, "See ?IdGroup in GAP", 1, 1 );
InstallSCSCPprocedure( "IdGroup512ByCode", IdGroup512ByCode, 
	"Identification of groups of order 512 using the ANUPQ package", 1, 1 );

# Important MIP (modular isomorphism problem for group algebras of finite p-group 
# over the field of p elements) invariant
InstallSCSCPprocedure( "QuillenSeriesByIdGroup", QuillenSeriesByIdGroup, 
	"Quillen series of a finite p-group given by IdGroup (list of two integers)", 1, 1 );

# Service used to compute automorphism groups of transformation semigroups with
# the MONOID package, which requires the GRAPE package, and the latter requires 
# the external program 'nauty' by Brendan D. McKay
InstallSCSCPprocedure( "WS_AutomorphismGroup", AutomorphismGroup, 1, 1 );
	
# Series of factorisation methods from the GAP package FactInt
InstallSCSCPprocedure("WS_FactorsTD", FactorsTD, 
	"FactorsTD from FactInt package, see ?FactorsTD in GAP", 1, 2 );
InstallSCSCPprocedure("WS_FactorsPminus1", FactorsPminus1, 
	"FactorsPminus1 from FactInt package, see ?FactorsPminus1 in GAP", 1, 4 );
InstallSCSCPprocedure("WS_FactorsPplus1", FactorsPplus1, 
	"FactorsPplus1 from FactInt package, see ?FactorsPplus1 in GAP", 1, 4 );
InstallSCSCPprocedure("WS_FactorsECM", FactorsECM, 
	"FactorsECM from FactInt package, see ?FactorsECM in GAP", 1, 5 );
InstallSCSCPprocedure("WS_FactorsCFRAC", FactorsCFRAC, 
	"FactorsCFRAC from FactInt package, see ?FactorsCFRAC in GAP", 1, 1 );
InstallSCSCPprocedure("WS_FactorsMPQS", FactorsMPQS, 
	"FactorsMPQS from FactInt package, see ?FactorsMPQS in GAP", 1, 1 );

InstallSCSCPprocedure("WS_ConwayPolynomial", ConwayPolynomial, "See ?ConwayPolynomial in GAP", 2, 2 );

InstallSCSCPprocedure( "PointImages", PointImages, 
	"1st argument is a permutation group G, 2nd is an integer n. Returns the set of images of n under generators of G", 2, 2 );

RandomPolynomial:=function(n)
local fam, f;
fam:=FamilyObj(1);
f:=LaurentPolynomialByCoefficients( fam, List([1..n],i->Random(Integers)), 0, 1 );
return f;
end;

InstallSCSCPprocedure("WS_RandomPolynomial", RandomPolynomial,
	"Calls LaurentPolynomialByCoefficients to generate a random polynomial", 0, 1 );

RandomPolynomialAsString:=function(n)
return String(RandomPolynomial(n));
end;

InstallSCSCPprocedure("WS_RandomPolynomialAsString", RandomPolynomialAsString,
	"Calls LaurentPolynomialByCoefficients to generate a random polynomial", 0, 1 );

KaratsubaPolynomialMultiplicationExtRepByString:=function(s1,s2)
return String( KaratsubaPolynomialMultiplicationExtRep( EvalString(s1), EvalString(s2) ) );
end;

InstallSCSCPprocedure("WS_KaratsubaStr", KaratsubaPolynomialMultiplicationExtRepByString, 
	"See Examples chapter in the SCSCP package manual", 2, 2 );

KaratsubaPolynomialMultiplicationExtRepByStringWithFixedIndeterminant:=function(s1,s2)
#fam:=FamilyObj(1);
# local x_1;
x_1:=Indeterminate(Rationals,"x_1");
return String( KaratsubaPolynomialMultiplication ( EvalString(s1), EvalString(s2) ) );
end;

InstallSCSCPprocedure("WS_KaratsubaStr_x", KaratsubaPolynomialMultiplicationExtRepByStringWithFixedIndeterminant, 
	"See Examples chapter in the SCSCP package manual", 2, 2 );


Polynomial2String:=function(s)
return String(s);
end;

InstallSCSCPprocedure("WS_Polynomial2String", Polynomial2String,
	"String representation of the polynomial", 1, 1 );

InstallSCSCPprocedure("WS_Karatsuba", KaratsubaPolynomialMultiplicationBetter, 
	"See Examples chapter in the SCSCP package manual", 2, 2 );

ResultantWS:=function(s1,s2)
#fam:=FamilyObj(1);
# local x_1;
x_1:=Indeterminate(Rationals,"x_1");
return String( Resultant ( EvalString(s1), EvalString(s2), 1 ) );
end;

InstallSCSCPprocedure("WS_Resultant", ResultantWS,
	"See Sec 64.6 in GAP Manual", 2, 2 );

ResWS:=function(n)
local fam,f,g,z;
fam:=FamilyObj(1);
# n:=200;
f:=LaurentPolynomialByCoefficients( fam, List([1..n],i->Random(Integers)), 0, 1 );
g:=LaurentPolynomialByCoefficients( fam, List([1..n],i->Random(Integers)), 0, 1 );
z:=Resultant(f,g,1);
return z ; 
end;

InstallSCSCPprocedure("WS_Res", ResWS,
	"See Sec 64.6 in GAP Manual", 1, 1 );

GroebnerBasisWS:=function(m,l)
local l1,n;
x_1:=Indeterminate(Rationals,"x_1");
x_2:=Indeterminate(Rationals,"x_2");
x_3:=Indeterminate(Rationals,"x_3");
n:=Length(l);
l1:=List([1..n],i->EvalString(l[i]));
return String (GroebnerBasis(l1,MonomialLexOrdering()));
end;

InstallSCSCPprocedure("WS_GroebnerBasis", GroebnerBasisWS,
	"GroebnerBasis; See Sec 64.17 in GAP Manual", 2, 2 );

ParMap:=function( list, map_fct )
local res;
res:=EvaluateBySCSCP("parMap", [ map_fct, list ], "localhost", 12321);
return res.object;
end;

ParMapFold:=function( list, neutral, map_fct, fold_fct )
local res;
res:=EvaluateBySCSCP("parMapFold", [ map_fct, fold_fct, neutral, list ], "localhost", 12321);
return res.object;
end;

InstallSCSCPprocedure("WS_FactorsInt", FactorsInt,
        "See Sec 14.3 in GAP Manual", 1, 1);

InstallSCSCPprocedure("WS_GcdInt", GcdInt,
	"See Sec 14.2 in GAP Manual", 2, 2 );
        
InstallSCSCPprocedure("WS_ChineseRem", ChineseRem,
	"See Sec 14.2 in GAP Manual", 2, 2 );

        
#############################################################################
#
# procedures for the UnitLib package for the parallel computation of the
# normalized unit group of a modular group algebra of a finite p-group
# from the GAP small groups library
#
if LoadPackage("unitlib") = true then
  if CompareVersionNumbers( GAPInfo.PackagesInfo.("unitlib")[1].Version, "3.0.0" ) then
	InstallSCSCPprocedure( "NormalizedUnitCFpower", NormalizedUnitCFpower );
	InstallSCSCPprocedure( "NormalizedUnitCFcommutator", NormalizedUnitCFcommutator );
  fi;
fi;


#############################################################################
#
# procedure to test pickling/unpickling from the IO package for data encoding
# 
IO_UnpickleStringAndPickleItBack:=function( picklestr )
return( IO_PickleToString( IO_UnpickleFromString( picklestr ) ) );
end;

InstallSCSCPprocedure( "IO_UnpickleStringAndPickleItBack", IO_UnpickleStringAndPickleItBack, 
	"To test how pickling format from IO package may be used for data transmitting (see ?IO_Pickle, ?IO_Unpickle)", 1, 1 );


#############################################################################
#
# Finally, we start the SCSCP server. 
#
#############################################################################

RunSCSCPserver( SCSCPserverAddress, SCSCPserverPort );
